// In contrast to sim_cell_division1.cl, this kernel consolidates the data generated by sim_cell_division1.cl.

{
	float3 my_position = in_position[get_global_id(0)].xyz;
	//"float3 my_velocity = in_velocity[get_global_id(0)].xyz;"
	float3 my_acceleration = (float3)(0.0f, 0.0f, 0.0f);

	float my_size = in_position[get_global_id(0)].w;

	//"position[get_global_id(0)];"
	//"float4 current_normal = vload_half4(get_global_id(0), in_normal);"			// Load the normal and convert the halfs to floats.
    // dot product = 0 means that the other particle is in the plane of the membrane.
	for(int a=0; a<count; a++)
	{
		float3 your_position = in_position[a].xyz;
		float dist = distance(my_position, your_position);

		// TODO: remove this if-statement:
		if(dist <= 0.03f) dist = 0.03f;

		// Normalize:
		float3 force_direction = (my_position - your_position) / dist;

		// Lennard-Jones Potential:
		//float force_magnitude = 24.0f * (0.5f) / dist * (2.0f*pown(8.0f / dist, 12) - pown(8.0f / dist, 6));
		float force_magnitude = max(0.0f, in_position[a].w + my_size - dist);

		float3 force = force_magnitude * force_direction;
		//"float3 acceleration = 1.0f * force;"

		// Discard values that are NAN (for test purposes):
		if (!isnan(fast_length(force)) && !isinf(fast_length(force)))

		my_acceleration = my_acceleration + force * 1.0f;	// TODO: add mass to particles (currently: 1.0f).
	}

	// Calculate velocity (based on timestep):
	//my_acceleration = my_acceleration - in_velocity[get_global_id(0)].xyz * 0.1f;
	//float3 my_velocity = in_velocity[get_global_id(0)].xyz + (timestep * my_acceleration);
	float3 my_velocity = (timestep * my_acceleration);
	my_position = my_position + (timestep * my_velocity);

	// Upload the values:
	out_velocity[get_global_id(0)] = (float4) (my_velocity, 1.0f); // Velocity Damping
	out_position[get_global_id(0)] = (float4) (my_position, min(my_size + 0.006f * timestep, 5.0f));
	//"out_position[get_global_id(0)] = (float4) (0.0f, 1.0f, 2.0f, 1.0f);"
}
