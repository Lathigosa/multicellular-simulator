kernel void empty()
{
	
}

kernel void return_constant(global float4* out_constant)
{
	out_constant[get_global_id(0)] = (float4)(0.0f, 100.0f, 0.0f, 1.0f);
}

// In contrast to sim_cell_division1.cl, this kernel consolidates the data generated by sim_cell_division1.cl.

kernel void cell_hookian_repel(global float4* out_position,
										global float4* out_velocity,
										global const float4* in_position,
										global const float4* in_velocity)
										//"global const float4* in_normal,"		// Indicates the rotation of the particle as well.
										//private int count,
										//private float timestep)	// TODO: possibly replace "float4* normal" with "half* normal" and use vload_half4(index, normal) to access it.
{
	int count = 32*32;
	float timestep = 0.1;
	
	float3 my_position = in_position[get_global_id(0)].xyz;
	//"float3 my_velocity = in_velocity[get_global_id(0)].xyz;"
	float3 my_acceleration = (float3)(0.0f, 0.0f, 0.0f);

	float3 my_normal = (float3)(0.0f, 0.0f, 1.0f);		// TODO: get normal

	//"position[get_global_id(0)];"
	//"float4 current_normal = vload_half4(get_global_id(0), in_normal);"			// Load the normal and convert the halfs to floats.
    // dot product = 0 means that the other particle is in the plane of the membrane.
	for(int a=0; a<count; a++)
	{
		float3 your_position = in_position[a].xyz;
		float3 your_normal = (float3)(0.0f, 0.0f, 1.0f);	// TODO: get normal
		float dist = distance(my_position, your_position);

		// TODO: remove this if-statement:
		if(dist <= 0.3f) dist = 1.0f;

		// Normalize:
		float3 force_direction = (my_position - your_position) / dist;

		// Lennard-Jones Potential:
		//float force_magnitude = 24.0f * (0.5f) / dist * (2.0f*pown(8.0f / dist, 12) - pown(8.0f / dist, 6));
		float force_magnitude = max(0.0f, 50.0f - dist);
		//"float force_size = 1.0f;"

		//"force_magnitude = force_magnitude * (1.0f - fabs(dot(my_normal, force_direction)));"

		float3 force = force_magnitude * force_direction;
		//"float3 acceleration = 1.0f * force;"

		// Discard values that are NAN (for test purposes):
		if (!isnan(fast_length(force)) && !isinf(fast_length(force)))

		my_acceleration = my_acceleration + force * 1.0f;	// TODO: add mass to particles (currently: 1.0f).
	}

	// Calculate velocity (based on timestep):
	//my_acceleration = my_acceleration - in_velocity[get_global_id(0)].xyz * 0.1f;
	//float3 my_velocity = in_velocity[get_global_id(0)].xyz + (timestep * my_acceleration);
	float3 my_velocity = (timestep * my_acceleration);
	my_position = my_position + (timestep * my_velocity);

	// Upload the values:
	out_velocity[get_global_id(0)] = (float4) (my_velocity, 1.0f); // Velocity Damping
	out_position[get_global_id(0)] = (float4) (my_position, 1.0f);
	//"out_position[get_global_id(0)] = (float4) (0.0f, 1.0f, 2.0f, 1.0f);"
}
